Строки
======

.. py:class:: str

    объект, строка   

    >>> str(), str([1,2]) 
    '', '[1, 2]'

    >>> str(b"\xf1\xf2\xf0\xee\xea\xe0") # вернет строку не зависима от типа аргумента
    "b'\\xf1\\xf2\\xf0\\xee\\xea\\xe0'"
    
    >>> str(b"\xf1\xf2\xf0\xee\xea\xe0", "ср1251") # вернет строку именно из типа bytes или bytearray
    'строка'


    .. warning:

        начиная с 3 питона, это уже unicode-строки


        >>> 'ilnurgi' + '.ru'
        'ilnurgi.ru'

        >>> 'ilnurgi' * 3
        'ilnurgiilnurgiilnurgi'

        >>> 'il' in 'ilnurgi'
        True

        >>> 'il' not in 'ilnurgi'
        False

        >>> 'ilnurgi'[0]
        'i'

        >>> 'ilnurgi'[2]
        'n'

        >>> 'ilnurgi'[:2]
        'il'

        >>> 'ilnurgi'[-2:]
        'gi'


    .. py:staticmethod:: maketrans(x [, y [, z]])

        создает таблицу символов

        * Если указан только первый параметр, то он должен быть словарем:
        
            >>> t = str.maketrans({"a": "А", "о": "О", "с": None})
            >>> t
            {1072: 'А', 1089: None, 1086: 'О'}
            >>> "cтpoкa".translate(t)
            'трОкА'

        * Если указаны два первых параметра, то они должны быть строками одинаковой длины:
        
            >>> t = str.maketrans("абвгдежзи", "АБВГДЕЖЗИ")
            >>> t
            {1072: 1040, 1073: 1041, ...}
            >>> "aбвгдeжзи".translate(t)
            'АБВГДЕЖЗИ'

        * В третьем параметре можно дополнительно указать строку из символов, которым будет сопоставлено значение None.

            >>> t = str.maketrans("123456789", "О" * 9, "str")
            >>> t
            {116: None, 115: None, 114: None, 49: 48, ююю}
            >>> "strl23456789str".translate(t)
            '000000000'


    .. py:method:: capitalize()
    
        Возвращает строку, у которой первая буква заменена на прописную
        
        >>> 'ilnur'.capitalize()
        'Ilnur'


    .. py:method:: center(width, [pad])

        :param int width: длина возвращаемой строки
        :param str pad: символ, которыми оформляются отступы, по умолчанию пробел

        Возвращает строку, заданной длины, выравненная по центру.

        >>> 'ilnur'.center(7)
        ' ilnur '


    .. py:method:: count(sub [, start [, end]])
        
        :param str sub: искомая строка
        :param int start: начальная позиция
        :param int end: конечноая позиция

        Возвращает число, количество вхождений искомой строки в исходной строке.
        
        >>> 'Help me! Help!'.count('Help')
        2


    .. py:method:: decode([coding, errors])
        
        :param str coding: кодировка
        :param errors: ???
        
        Возвращает строку, раскодированная из указанной кодировки в юникод.
            
        >>> '\xd0\xb8\xd0\xbb\xd1\x8c\xd0\xbd\xd1\x83\xd1\x80'
        '\xd0\xb8\xd0\xbb\xd1\x8c\xd0\xbd\xd1\x83\xd1\x80'
        >>> '\xd0\xb8\xd0\xbb\xd1\x8c\xd0\xbd\xd1\x83\xd1\x80'.decode('utf-8')
        u'\u0438\u043b\u044c\u043d\u0443\u0440'


    .. py:method:: encode([coding, errors])
        
        :param str coding: кодировка
        
        Возвращает строку, закодированную из юникода в указанную кодировку.
        
        >>> u'Ильнур'
        u'\u0418\u043b\u044c\u043d\u0443\u0440'
        >>> u'Ильнур'.encode('cp1251')
        '\xc8\xeb\xfc\xed\xf3\xf0'


    .. py:method:: endswith(sub[, start [, end]])
        
        :param str sub: искомая строка
        :param int strat: начальная позиция
        :param int end: конечная позиция
        
        Возвращает True | False, если строка заканчивается c искомой строки
        >>> 'ilnur'.endswith('il')
        False
        >>> 'ilnur'.endswith('nur')
        True


    .. py:method:: expandtabs([tabsize = 8])
        
        :param int tabsize: количество пробелов за место табуляции

        Возвращает строку, символы табуляции заменены указанным количеством пробелов.
        
        >>> u'\tИльнур'.expandtabs()
        u'        \u0418\u043b\u044c\u043d\u0443\u0440'


    .. py:method:: find(sub[, start [, end]])
        
        :param str sub: искомая строка
        :param int start: начальная позиция
        :param int end: конченая позиция

        Возвращает число, позиция в котором встречается искомая строка, если ничего не найдено возвращает -1, поиск ведется слева.
        
        >>> 'ilnur'.find('nur')
        2
        >>> 'ilnur'.find('run')
        -1


    .. py:method:: format(*args, **kwargs)
        
        Возвращает строку, форматированную в соответствии с переданными параметрами
        
        Синтаксис: `{[Поле][!Функция][:Формат]}`

        Синтаксис формата: `[[Заполнитель] Выравнивание] [Знак] [#] [0] [Ширна] [,] [.Точность] [Преобразование]`

            * `заполнитель` - заполнитель пространства в поле
            * `выравнивание` - выравниваение поля

                * `<` - по левому краю
                * `>` - по правому краю
                * `^` - по центру
                * '=' - знак числа по левому краю, число по правому

            * `ширина` - ширина поля

                >>> "'{0:10}'".format(3)
                '         3'
                >>> "'{0:{1}}'".format(3, 10)
                '         3'

            * `знак` - управляет выводом знака числа

                * `+` - обязательный вывод знаков
                * `-` - знаки только для отрицательных
                * `пробел` - вывод отрицательных знаков и пробел вместо положительного знака

            * `преобразование` - преобразование чисел

                * `b` - двоичное значение
                * `c` - преобразование числа в символ
                * `d` - десятичное значение
                * `n` - аналогично `d`, но с учетом локали
                * `o` - восьмиричное значение
                * `x`, 'X' - шестнадцатиричное значение 
                * `f`, `F` - вещественное число в десятичном представлении
                * `e`, `E` - вещественное число в экспоненциальной форме
                * `g`, `G` - эквивалентно `f`, `e` или `E` (выбирается более короткая запись числа)
                * `n` - аналогично `g`, но учитвает локаль
                * `%` - умножает число на 100 и добавляет символ процента в конце
                * `` - 
                * `` - 
                * `` - 
                * `` - 

        >>> '{0} и {1}'.format('фарш', 'яйца')
        'фарш и яйца'

        >>> 'Этот {food} — {adjective}.'.format(food='фарш', adjective='непередаваемо ужасен')
        Этот фарш — непередаваемо ужасен.

        >>> 'История о {0}е, {1}е, и {other}е.'.format('Билл', 'Манфред', other='Георг')
        История о Билле, Манфреде, и Георге.

        >>> 'Значение ПИ — примерно {0:.3f}.'.format(3.14))
        Значение ПИ — примерно 3.14159.

        >>> '{0:10} ==> {1:10d}'.format('Sjoerd', 4127)
        Sjoerd     ==>       4127        

        >>>table = {'Sjoerd': 4127, 'Jack': 4098, 'Dcab': 8637678}
        >>> 'Jack: {0[Jack]:d}; Sjoerd: {0[Sjoerd]:d}; Dcab: {0[Dcab]:d}'.format(table))
        Jack: 4098; Sjoerd: 4127; Dcab: 8637678'

        # вывод в двоичном формате
        >>> '{0:b} & {1:b} = {2:b}'.format(100, 75, 100 & 75)
        '1100100 & 1001011 = 1000000'


    .. py:method:: index(sub [, start [, end]])
        
        :param str text: искомая строка
        :param int start: начальная позиция
        :param int end: конченая позиция
        :raise: ValueError

        Возвращает число, позиция в котором встречается искомая строка, если ничего не найдено вызовет исключение, поиск ведется слева.
        
        >>> 'ilnur'.index('nur')
        2
        >>> 'ilnur'.index('run')
        Traceback (most recent call last):
            File "<stdin>", line 1, in <module>
        ValueError: substring not found


    .. py:method:: isalpha()
        
        Возвращает True | False, если строка содержит только буквы
        
        >>> '123'.isalpha()
        False
        >>> 'ilnur'.isalpha()
        True


    .. py:method:: isalnum()
        
        Возвращает True | False, если строка содержит только буквы и цифры
        

    .. py:method:: isdigit()
        
        Возвращает True | False, если строка содержит только цифры
        
        >>> '123'.isdigit()
        True
        >>> 'ilnur'.isdigit()
        False
        

    .. py:method:: isdecimal()
        
        Возвращает True | False, если строка содержит только десятичные символы
        

    .. py:method:: islower()

        Возвращает True | False, если строка содержит только строчные буквы
        

    .. py:method:: isnumeric()
        
        Возвращает True | False, если строка содержит только числовые символы

        >>> "\u2155".isnumeric(), "\u2155".isdigit()
        (True, False)
        >>> print("\u2155")
        '1/5'


    .. py:method:: isspace()
        
        Возвращает True | False, если строка содержит только пробельные символы

        >>> '123'.isalpha()
        False


    .. py:method:: istitle()

        Возвращает True | False, если строка содержит слова начинающиеся с заглавной буквы


    .. py:method:: isupper()

        Возвращает True | False, если строка содержит только заглавные буквы


    .. py:method:: join(iter)

        :param iter iter: итерируемый объект

        Возвращает строку, содержащий сконкатенированные значения исходной строки с итерируемым объектом.

        >>> 'ilnur'.join('---')
        '-ilnur-ilnur-


    .. py:method:: ljust(width, [fill])

        :param int width: длина возвращаемой строки
        :param str fill: символ, которыми оформляются отступы, по умолчанию пробел

        Возвращает строку, заданной длины, выравненная слева.

        >>> 'ilnur'.ljust(7)
        'ilnur  '


    .. py:method:: lower()
        
        Возвращает строку, в нижнем регистре 
        
        >>> 'iLnur'.lower()
        'ilnur'


    .. py:method:: lstrip([chrs])
        
        Возвращает строку, с удаленными пробелами слева

        :param iter chrs: удаляемые символы

        >>> ' ilnur privet '.lstrip()
        'ilnur privet  '


    .. py:method:: partition(sep)

        Находит nервое вхождение символа-разделителя в строку и возвращает кортеж из трех элементов. 

            * первый элемент - содержать фрагмент, рас­nоложенный nеред разделителем
            * второй элемент - символ-разделитель
            * третий эле­мент - фрагмент, расnоложенный nосле символа-разделителя. 

        Поиск nроизводится сле­ва наnраво. Если символ-разделитель не найден, то nервый элемент кортежа будет со­держать всю строку, а остальные элементы будут nустыми. 

        >>> "wordl word2 wordЗ".partition(" ")
        ('wordl', ' ', 'word2 word3')
        
        >>> "wordl word2 wordЗ".partition("\n")
        ( 'wordl word2 wordЗ', '', '')


    .. py:method:: replace(old, new, [maxreplace])
        
        :param str old: старая
        :param str new: новая
        :param ind maxreplace: максимальное количество замен

        Возвращает строку, с замененой строкой на новую строку.
        
        >>> 'ilnur'.replace('nur','nurgi')
        'ilnurgi'


    .. py:method:: rfind(sub [, start [, end]])

        :param str sub: искомая строка
        :param int start: начальная позиция
        :param int end: конченая позиция

        Аналог :py:meth:`find`.  
        Возвращает число, с которого начинается искомая строка, если ничего не найдено возвращает -1, поиск ведется справа. 
        

    .. py:method:: rindex(sub [, start [, end]])
        
        :param str sub: искомая строка
        :param int start: начальная позиция
        :param int end: конченая позиция

        Аналог :py:meth:`index`.  
        Возвращает число, с которого начинается искомая строка, если ничего не найдено вызовет исключение, поиск ведется справа.


    .. py:method:: rjust(width, [fill])

        :param int width: длина возвращаемой строки
        :param str fill: символ заполенения пустых мест

        Возвращает строку, заданной длины, выравненная по правому краю.
        
        >>> 'ilnur'.rjust(7)
        '  ilnur'


    .. py:method:: rpartition(sep)

        метод аналогичен методу :py:meth:`str.partition`, но nоиск символа­ разделителя nроизводится не слева наnраво, а, наоборот, сnрава налево. Если символ­ разделитель не найден, то nервые два элемента кортежа будут nустыми, а третий эле­мент будет содержать всю строку. 

        >>> "wordl word2 wordЗ".rpartition(" ")
        ('wordl word2', ' ', 'wordЗ')

        >>> "wordl word2 wordЗ".rpartition("\n")
        (' ', '', 'wordl word2 word3')


    .. py:method:: rsplit([razd, maxcount])

        :param str razd: разделитель
        :param int maxcount: количество разбиений

        Возвращает список, полученный из строки, путем разделения разделителем.

        >>> 'i l n u r'.split(' ')
        ['i', 'l', 'n', 'u', 'r']


    .. py:method:: rstrip([chrs])
        
        Возвращает строку, с удаленными пробелами слева/справа или с обоих концов соответственно.

        :param iter chrs: удаляемые символы
       
        >>> ' ilnur privet '.rstrip()
        ' ilnur privet'


    .. py:method:: split([sep, maxcount])

        :param str sep: разделитель
        :param int maxcount: max количество разбиений

        Возвращает список, полученный из строки, путем разделения разделителем.

        >>> 'i l n u r'.split(' ')
        ['i', 'l', 'n', 'u', 'r']


    .. py:method:: splitlines([keepends])
        
        :param keepends: включать ли символ перевода каретки
        :var keepends: True/False
        
        Возвращает список, аналогично :py:meth:`split`, но использующий в качестве разделителя переход на новую строку. Символы перехода на новую строку включаются в результат, только если необязательный аргумент keepends равен 1.

        >>> """Hello World!\nHello!""".splitlines()
        ['Hello World!', 'Hello!']


    .. py:method:: startswith(sub[, start [, end]])
        
        :param str sub: искомая строка
        :param int strat: начальная позиция
        :param int end: конечная позиция
        
        Возвращает True | False, если строка начинается c искомой строки

        >>> 'ilnur'.startswith('il')
        True
        >>> 'ilnur'.startswith('nur')
        False


    .. py:method:: strip([chrs])

        :param iter chrs: удаляемые символы

        Возвращает строку, с удаленными пробелами c обоих концов соответственно.

        >>> ' ilnur '.strip()
        'ilnur'


    .. py:method:: swapcase()
        
        Возвращает строку, в которой регистр букв изменен с верхнего на нижний и наоборот.

        >>> 'Ilnur'.swapcase()
        'iLNUR'


    .. py:method:: title()
        
        Возвращает строку, в которой регистр букв соответствует заголовку.
        
        >>> 'ilnur'.title()
        'ILNUR'


    .. py:method:: translate(table, [deletechars])

        Выполняет преобразование строки в соответствии с таблицей замены. Упростить создание `таблицы символов` позволяет статический метод :py:meth:`maketrans`

        :param table: таблица замены
        :param deletechars: удаляемые символы

        >>> s = "Пример"
        >>> d = {ord('П''): None, ord('p'): ord('P')}
        >>> d 
        {1088: 1056, 1055: None}
        >>> s.translate(d)
        'РимеР'

    .. py:method:: upper()
        
        Возвращает строку, в верхнем регистре
        
        >>> 'iLnur'.upper()
        'ILNUR'


    .. py:method:: zfill(width)

        :param int width: длина возвращаемой строки
        
        Возвращает строку, заданной длины, пустое пространство слева заполнится нулями

        >>> '12'.zfill(5)
        '00012'
        

Функции работы со строками
--------------------------


.. py:function:: str([obj, encode, errors='strict'])

    :param obj: объект (:py:class:`str`, :py:class:`bytes`, :py:class:`bytearray`)
    :param encode: кодировка для :py:class:`bytes`, :py:class:`bytearray`
    :param str errors: обработка ошибок для :py:class:`bytes`, :py:class:`bytearray`

    Возвращает :py:class:`str`, преобразованный из объекта

    Через атрибут `errors` настраивается обработка ошибок:

        * `strict` - при ошибке возбуждается исключение :py:class:`UnicodeDecodeError`
        * `replace` - неизвестный символ заменяется символом, имеющим код \uFFFD
        * `ignore` - неизвестные символы игнорируются
    
    >>> str(125), str( [1, 2, 3])
    ('125', '[1, 2, 3]')
    
    >>> str((1, 2, 3)), str({"x": 5, "у": 10})
    ('(1, 2, 3)', "{'у': 10, 'х': 5}")
    
    >>> str(bуtеs("строка", "utf-8") )
    "b'\\xd1\\x81\\xd1\\x82\\xd1\\x80\\xd0\\xbe\\xd0\\xba\\xd0\\хbО'"
   
    >>> str(bytearray("строка", "utf-8") )
    "bytearray(b'\\xd1\\x81\\xd1\\x82\\xd1\\x80\\xd0\\xbe\\xd0\\xba\\xdO\\xbO')"
    
    >>> str(bytes("строка1", "utf-8"), "utf-8")
    'строка1'
    
    >>> str(bytes("строка1", "utf-8"), "ascii", "strict")
    Traceback (most recent са11 1ast):
      Fi1e "<pyshe11#16>", 1ine 1, in <modu1e>
        str(bytes("строка1", "utf-8"), "ascii", "strict")
    UnicodeDecodeError: 'ascii' codec can't decode byte Oxd1 in position 0: ordina1 not in range(128)
    
    >>> str(bytes("строка1", "utf-8"), "ascii", "ignore")
    '1'


Форматирование строки
---------------------

>>> '%s' % 1
'1'

>>>'%[Ключ], [Флаг], [Ширина], [Точность]ТипПреобразования'

* ключ - ключ словаря

    >>> '%(name)s' % {'name': 'python'} # ключ словаря
    'python'

* флаг - флаг преобразования

    >>> # '#' добавляет символ типа    
    >>> "%#o %#o %#o" % (Оо77, 10, 10.5)
    0o77 0o12 0o12
    >>> "%#x %#х %#х" % (Oxff, 10, 10.5)
    Oxff Оха Оха    
    >>> "%#X %#Х %#Х" % (Oxff, 10, 10.5)
    OXFF ОХА ОХА    
    >>> "%#.0F %.0F" % (300, 300)
    300. 300

    >>> '0' - задает наличие ведущих нулей для числового значения
    >>> '%d - %05d' % (3, 3) # 5 - ширина поля
    3 - 00003

    >>> '-' - задает выравнивание по левой границе
    >>> "'%5d' - '%-5d'" % (3, 3) # 5 - ширина поля
    '    3' - '3    ' -
    >>> "'%05d' - '%-05d'" % (3, 3)
    "'00003' - '3    '"

    >>> '+' - обязательный вывод знака чисел
    >>> "'%+d' - '%+d'" % (-3, 3)
    '-3' - '+3'

    >>> nробел - вставляет пробел перед положительным числом
    >>> "'%d' - '%d'" % (- 3, 3)
    '-3' - ' 3'

* ширина - минимальная ширина поля

    >>> "'%10d' - '%-10d'" % (3, 3)
    '         3' - '3         '
    >>> "'%3s''%10s'" % ("string", "string")
    'string''    string'"
    >>> "'%*s"%10s"' % (10, "string", "str") # ширина указана в кортеже
    '    string''       str'

* точность - количество знаков после точки для вещественных чисел

    >>>> "%s %f %.2f" % (math.pi, math.pi, math.pi)
    '3.141592653589793 3.141593 3.14'
    >>> "'%*.*f'" % (8, 5, math.pi) # значения берутся из кортежа
    ' 3.14159'

* тип преобразования

    * `s` - строка, преобразование через функцию `str()`
    * `r` - строка, преобразование через функцию `repr()`
    * `a` - строка, преобразование через функцию `ascii()`
    * `c` - число, значение символа
    * `d`, `i` - целая часть числа
    * `o` - восьмиричное значение
    * `x` - шестнадцатиричное значение
    * `Х` - шестнадцатиричное значение в верхнем регистре
    * `f`, `F` - вещественное число в десятичном представлении
    * `e`, `E` - вещественное число в экспоненциальном форме
    * `g`, `G` - эквивалентно `f` или `g` или `G` (выббирается более короткая запись)